<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- For Mobile Devices -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<title>Boost.SIMD: Hello World</title>
<!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link rel="icon" href="numscale_icon.png">
<link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="numscale.css" rel="stylesheet" type="text/css"/>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="numscale.js"></script>
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
<div class="container">
<div class="navbar-header responsive-logo">
<a class="navbar-brand" style="width: 10%" href="https://github.com/NumScale/boost.simd">Boost.SIMD </a>
<a href="http://numscale.implicitweb.fr/" title="Numscale" style="display: block; width: 25%; text-align: right; float: right"><img src="numscale.png" alt="Numscale" style="width:100%; padding-top: 10px; padding-bottom: 10px; " align="right"></a>
</div>
</div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div class="content" id="content">
<div class="container">
<div class="row">
<div class="col-sm-12 panel " style="padding-bottom: 35px;">
<div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="_quick_start.html"><span>Quick&#160;Start</span></a></li>
      <li><a href="tutorials.html"><span>Tutorials</span></a></li>
      <li><a href="faq.html"><span>FAQ</span></a></li>
      <li><a href="modules.html"><span>Reference&#160;documentation</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Hello World </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#hello-objectives">Objectives</a></li>
<li class="level1"><a href="#hello-getting-started">Getting Started</a></li>
<li class="level1"><a href="#hello-building-blocks">Basic Building Block</a><ul><li class="level2"><a href="#hello-building-blocks-pack">boost::simd::pack</a></li>
<li class="level2"><a href="#hello-loading-data">Loading Data into a Pack</a></li>
<li class="level2"><a href="#hello-building-blocks-operations">Operations on Pack</a></li>
<li class="level2"><a href="#hello-building-blocks-store">Storing the Result in memory</a></li>
</ul>
</li>
<li class="level1"><a href="#hello-compilation">Compiling the Code</a></li>
<li class="level1"><a href="#hello-results">Results</a></li>
<li class="level1"><a href="#hello-results-architectures">Different Architectures</a></li>
</ul>
</div>
<div class="textblock"><p>In this tutorial we will write and compile a very simple <b>SIMD</b> kernel to become familiar with the basics of <b>Boost.SIMD</b>.</p>
<h1><a class="anchor" id="hello-objectives"></a>
Objectives</h1>
<hr/>
<p>In this tutorial we will:</p><ul>
<li><a href="#hello-building-blocks">Introduce the basic __SIMD__ register abstraction, boost::simd::pack</a></li>
<li><a href="#hello-loading-data">Load data from memory into a boost::simd::pack</a></li>
<li><a href="#hello-building-blocks-operations">Perform a simple arithmetical calculation and print the result</a></li>
<li><a href="#hello-building-blocks-store">Store the results back into memory</a></li>
<li><a href="#hello-compilation">Compile and run the code</a></li>
<li><a href="#hello-results-architectures">Observe the different outputs from compiling the same code on different processors</a></li>
</ul>
<h1><a class="anchor" id="hello-getting-started"></a>
Getting Started</h1>
<hr/>
<p> <b>Boost.SIMD</b> is a header only library which means that each of its components is accessible through its corresponding include. The first step is to include the file which give you the main <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/simd/pack.hpp&gt;</span></div>
</div><!-- fragment --><p> In a similar way, all <b>Boost.SIMD</b> functions and constants may be accessed through their respective headers. For example to access boost:simd::cos, you must include:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/simd/function/cos.hpp&gt;</span></div>
</div><!-- fragment --><p>Similarly, constant values may be accessed as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/simd/constant/pi.hpp&gt;</span></div>
</div><!-- fragment --><p>All functions and constants are included in the same way.</p>
<table  align="center" width="90%" class="table-striped ">
<tr>
<th><dl class="section note">
<dt>Note</dt>
<dd>All of <b>Boost.SIMD</b> functionality is wrapped in the <code><a class="el" href="namespaceboost_1_1simd.html" title="Main Boost.SIMD namespace. ">boost::simd</a></code> namespace. The easiest way to do this is to assign an alias to it: <div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1simd.html">bs</a> = <a class="code" href="namespaceboost_1_1simd.html">boost::simd</a>;</div>
</div><!-- fragment -->This saves you from having to type the full namespace every time you call a <b>Boost.SIMD</b> function. </dd>
</dl>
</th></tr>
</table>
<h1><a class="anchor" id="hello-building-blocks"></a>
Basic Building Block</h1>
<hr/>
<h2><a class="anchor" id="hello-building-blocks-pack"></a>
boost::simd::pack</h2>
<p><a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> can be considered analagous to an <em>SIMD</em> register on your (or any other) machine. Operations performed on packs - from elementary operations such as addition to complicated functions such as sin(x) - will be performed using <em>SIMD</em> registers and operations if supported by your hardware. As shown in the following example, data must be manually loaded into and stored from these registers.</p>
<p>A <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> may contain many different primitive types, depending on the target machine. A type alias for a pack of float is declared as follows:</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> pack_t = <a class="code" href="singletonboost_1_1simd_1_1pack.html">bs::pack&lt;float&gt;</a>;</div>
</div><!-- fragment --> <h2><a class="anchor" id="hello-loading-data"></a>
Loading Data into a Pack</h2>
<p>One way to construct a <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> is to simply declare (default-construct) it. Such a pack may not zero-initialized and thus may contain arbitrary values.</p>
<div class="fragment"><div class="line">  pack_t res;</div>
</div><!-- fragment --><p> Another way to construct a <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> is to fill it with a single value. This so-called splatting constructor takes one scalar value and replicates it in all elements of the pack.</p>
<div class="fragment"><div class="line">  pack_t tens{10};</div>
</div><!-- fragment --><p> You may also construct a pack by passing a pointer to a block of contiguous, aligned memory.</p>
<div class="fragment"><div class="line">  std::vector&lt;float&gt; values(1000);</div>
<div class="line">  std::iota(values.begin(), values.end(), float(0));</div>
<div class="line">  pack_t ptr_pack(values.data());</div>
</div><!-- fragment --><p> When constructing a pack in this manner, you must ensure that there is sufficient data in the block of memory to fill the pack. For example, on an AVX enabled machine, a <b>SIMD</b> vector of <code>float32</code> contains <code>8</code> elements, or has a <b>cardinal</b> of <code>8</code>. Therefore, there must be at least <code>8</code> elements in the block of memory pointed to by this pointer. This same code compiled for the Intel KNL, would require that the block of memory contain <code>16</code> elements, otherwise there would be undefined behaviour at runtime. When writing vectorized code, care should be taken to write the code in as generic a manner as possible to ensure portability across architectures.</p>
<table  align="center" width="90%" class="table-striped ">
<tr>
<th><dl class="section note">
<dt>Note</dt>
<dd>Other functions exist to explicitly load data from unaligned memory, non-contiguous data and other more complex scenarios. These functions are presented in later tutorials. </dd>
</dl>
</th></tr>
</table>
<p>You may also construct a pack by passing a range of elements, however the length of this range must be equal to the cardinal of the pack.</p>
<div class="fragment"><div class="line">  std::list&lt;float&gt; data(pack_t::static_size);</div>
<div class="line">  std::iota(data.begin(), data.begin() + pack_t::static_size, float(0));</div>
<div class="line">  pack_t iter_pack(data.begin(), data.end());</div>
</div><!-- fragment --> <table  align="center" width="90%" class="table-striped ">
<tr>
<th><dl class="section note">
<dt>Note</dt>
<dd>Please note that very few architectures provide an efficient way of loading data in this manner as there is no guarantee that the data is contiguous. Such a load should only be used in very specific circumstances and never inside a critical loop. </dd>
</dl>
</th></tr>
</table>
<p>Here, we have introduced <code>pack_t::static_size</code> which is the cardinal of the pack.</p>
<p>Finally, you can also initializes every element of the <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> itself by enumerating them.</p>
<div class="fragment"><div class="line">  pack_t enum_pack({10, 11, 12, 13, 14, 15, 16, 17});</div>
</div><!-- fragment --><p> That this constructor makes the strong assumption that the number of elements in the constructor matches the cardinal of <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> on the target machine. Unless required, it is generally good practice to avoid depending on a fixed size for <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> unless the algorithm specifically requires it. The use of another constructor is strongly recommended over this one.</p>
<h2><a class="anchor" id="hello-building-blocks-operations"></a>
Operations on Pack</h2>
<p>Once initialized, operations on <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> instances are similar to scalar operations as all operators and standard library math functions are provided. In order to access all of these functions and operators, such as <a class="el" href="group__group-operator_gab7d2f36a67787bac4c1b2cfd05ba2b47.html#gab7d2f36a67787bac4c1b2cfd05ba2b47" title="Function object implementing plus capabilities. ">boost::simd::plus</a>, you must include the relevant header: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/simd/function/plus.hpp&gt;</span></div>
</div><!-- fragment --><p>A simple arithmetical operation is performed as follows:</p>
<div class="fragment"><div class="line">  res = (tens + elevens) * 2;</div>
</div><!-- fragment --> <h2><a class="anchor" id="hello-building-blocks-store"></a>
Storing the Result in memory</h2>
<p>The result may be saved to memory as follows:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">float</span> output[pack_t::static_size];</div>
<div class="line">  <a class="code" href="namespaceboost_1_1simd_af5521b79da254d7133fa74cfaf547e10.html#af5521b79da254d7133fa74cfaf547e10">bs::store</a>(res, &amp;output[0]);</div>
</div><!-- fragment --><p> Finally, we print the contents of a <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> by using the <code>operator&lt;&lt;</code> overload provided.</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; res &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h1><a class="anchor" id="hello-compilation"></a>
Compiling the Code</h1>
<hr/>
<p>The compilation of using <b>Boost.SIMD</b> is rather straight-forward: you must pass the path of of the <b>Boost.SIMD</b> include folder to your compiler as well as the path of your installation of <b>Boost</b>. It is strongly recommended that you enable all of your compiler optimizations, for example, <code>-O3</code> for g++, to exploit the full performance potential of <b>Boost.SIMD</b>. You should also pass the required compiler flag for your target architecture to enable the <b>SIMD</b> extensions, especially if you are cross-compiling. The exhaustive list of all compiler flags for all supported compilers is provided in the the <a class="el" href="_quick_start.html">Quick Start</a> guide.</p>
<p>For example, on <code>gcc</code>:</p>
<p><code>g++ my_code.cpp -O3 -DNDEBUG -o my_code -I/path/to/boost.simd/ -mavx</code></p>
<p>If use an IDE such as Visual Studio or XCode, set these flags and paths in your project settings. </p><table  align="center" width="90%" class="table-striped ">
<tr>
<th><dl class="section warning">
<dt>Warning</dt>
<dd>Some compilers, such as Microsoft Visual Studio, do not propagate the fact a given architecture specific option is triggered. In this case, you must also define an architecture specific preprocessor symbol. For example, if you want to use SSE4.2 on Visual Studio, set the /ARCH:SSE2 flag and define <code>BOOST_SIMD_ASSUME_SSE4_2</code> as a preprocessor definition. </dd>
</dl>
</th></tr>
</table>
<table  align="center" width="90%" class="table-striped ">
<tr>
<th><dl class="section warning">
<dt>Warning</dt>
<dd>We recommend using a 64bit compiler as this results in significantly better performance. </dd>
</dl>
</th></tr>
</table>
<h1><a class="anchor" id="hello-results"></a>
Results</h1>
<hr/>
<p>When the above program is compiled, this output should be seen:</p>
<p><code>{42,42,42,42}</code></p>
<p>Let's take a look at the generated assembly code (using <code>objdump</code> for example) :</p>
<div class="fragment"><div class="line">addps  0x2e6(%rip),%xmm0</div>
<div class="line">mulps  0x2ff(%rip),%xmm0</div>
<div class="line">movaps %xmm0,(%rsp)</div>
</div><!-- fragment --><p> This shows that *Boost.SIMD** performed as expected: the code has been vectorised! This may be seen by the emitted <code>*ps</code> instructions. Note how the abstractions introduced by <a class="el" href="singletonboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a> are completely free, they do not incur ant runtime penalty. The generated assembly is identical to that generated by handwritten <b>SIMD</b> instructions!</p>
<p>Now let's take a look at what happens when a <b>Boost.SIMD</b> code is compiled on different architecures:</p>
<h1><a class="anchor" id="hello-results-architectures"></a>
Different Architectures</h1>
<p>In this section we will examine what happens when the same code is compiled for different archiectures. The following code loads a pack of various primitive data types from aligned memory (<a class="el" href="tutorial-memory.html">Memory Alignment</a>) and prints it's contents.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> iota_and_print()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// The number of elements will be deduced automatically according to the target architecture selected</span></div>
<div class="line">  <span class="keyword">using</span> pack_t = <a class="code" href="singletonboost_1_1simd_1_1pack.html">bs::pack&lt;T&gt;</a>;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Allocates aligned memory using expected alignment</span></div>
<div class="line">  std::unique_ptr&lt;T[], ba::aligned_delete&gt; data(</div>
<div class="line">    (T*)(ba::aligned_alloc(pack_t::alignment, pack_t::static_size * <span class="keyword">sizeof</span>(T))));</div>
<div class="line">  std::iota(data.get(), data.get() + pack_t::static_size, T(1));</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Constructs a pack (which will call `boost::simd::aligned_load&lt;pack_t&gt;` to fill up its data)</span></div>
<div class="line">  pack_t p{data.get()};</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Now just print the loaded data</span></div>
<div class="line">  std::cout &lt;&lt; p &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  iota_and_print&lt;std::int8_t&gt;();</div>
<div class="line">  iota_and_print&lt;std::uint8_t&gt;();</div>
<div class="line">  <span class="comment">// --</span></div>
<div class="line">  iota_and_print&lt;std::int16_t&gt;();</div>
<div class="line">  iota_and_print&lt;std::uint16_t&gt;();</div>
<div class="line">  <span class="comment">// --</span></div>
<div class="line">  iota_and_print&lt;std::int32_t&gt;();</div>
<div class="line">  iota_and_print&lt;std::uint32_t&gt;();</div>
<div class="line">  <span class="comment">// --</span></div>
<div class="line">  iota_and_print&lt;std::int64_t&gt;();</div>
<div class="line">  iota_and_print&lt;std::uint64_t&gt;();</div>
<div class="line">  <span class="comment">// --</span></div>
<div class="line">  iota_and_print&lt;float&gt;();</div>
<div class="line">  <span class="comment">// --</span></div>
<div class="line">  iota_and_print&lt;double&gt;();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Let's compile this code for SSE2:</p>
<div class="fragment"><div class="line">clang++ -Wall -Wextra -<a class="code" href="namespacestd.html">std</a>=c++11 -I/tmp/<a class="code" href="namespaceboost.html">boost</a>.<a class="code" href="namespaceboost_1_1simd.html">simd</a>.install/include -msse2 /tmp/main.cpp</div>
</div><!-- fragment --><p> And examine it's output:</p>
<div class="fragment"><div class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)</div>
<div class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)</div>
<div class="line">(1, 2, 3, 4, 5, 6, 7, 8)</div>
<div class="line">(1, 2, 3, 4, 5, 6, 7, 8)</div>
<div class="line">(1, 2, 3, 4)</div>
<div class="line">(1, 2, 3, 4)</div>
<div class="line">(1, 2)</div>
<div class="line">(1, 2)</div>
<div class="line">(1, 2, 3, 4)</div>
<div class="line">(1, 2)</div>
</div><!-- fragment --><p> Now compile it using AVX and the following output is printed: </p><div class="fragment"><div class="line">clang++ -Wall -Wextra -std=c++11 -I/tmp/<a class="code" href="namespaceboost.html">boost</a>.<a class="code" href="namespaceboost_1_1simd.html">simd</a>.install/include -mavx /tmp/main.cpp</div>
</div><!-- fragment --> <div class="fragment"><div class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32)</div>
<div class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32)</div>
<div class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)</div>
<div class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)</div>
<div class="line">(1, 2, 3, 4, 5, 6, 7, 8)</div>
<div class="line">(1, 2, 3, 4, 5, 6, 7, 8)</div>
<div class="line">(1, 2, 3, 4)</div>
<div class="line">(1, 2, 3, 4)</div>
<div class="line">(1, 2, 3, 4, 5, 6, 7, 8)</div>
<div class="line">(1, 2, 3, 4)</div>
</div><!-- fragment --><p>As you can see, the number of elements in each <b>SIMD</b> vector has doubled, as an AVX vector has twice the number of elements as an SSE2 vector. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 9 2016 11:17:30 for Boost.SIMD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
