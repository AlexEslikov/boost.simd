<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- For Mobile Devices -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<title>Boost.SIMD: Distance between Points</title>
<!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link rel="icon" href="numscale_icon.png">
<link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="numscale.css" rel="stylesheet" type="text/css"/>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="numscale.js"></script>
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
<div class="container">
<div class="navbar-header responsive-logo">
<a class="navbar-brand" style="width: 10%" href="https://github.com/NumScale/boost.simd">Boost.SIMD </a>
<a href="http://numscale.implicitweb.fr/" title="Numscale" style="display: block; width: 25%; text-align: right; float: right"><img src="numscale.png" alt="Numscale" style="width:100%; padding-top: 10px; padding-bottom: 10px; " align="right"></a>
</div>
</div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div class="content" id="content">
<div class="container">
<div class="row">
<div class="col-sm-12 panel " style="padding-bottom: 35px;">
<div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="_quick_start.html"><span>Quick&#160;Start</span></a></li>
      <li><a href="tutorials.html"><span>Tutorials</span></a></li>
      <li><a href="faq.html"><span>FAQ</span></a></li>
      <li><a href="modules.html"><span>Reference&#160;documentation</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Distance between Points </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#distance-objectives">Objectives</a></li>
<li class="level1"><a href="#distance-intro">Distance between two points</a><ul><li class="level2"><a href="#distance-simd">The SIMD Calculation</a></li>
<li class="level2"><a href="#distance-interleave">How to deal with input data which is not properly ordered</a></li>
</ul>
</li>
<li class="level1"><a href="#distance-speed-up">Measuring the speed up</a></li>
<li class="level1"><a href="#distance-performance-analysis">Performance analysis</a></li>
<li class="level1"><a href="#distance-full-code">Full code</a></li>
</ul>
</div>
<div class="textblock"><p>In this tutorial we will examine how to calculate the cartesian distance between a 2D reference point and a vector of 2D points. This could be used for example in a clustering algorithm such as dbscan.</p>
<h1><a class="anchor" id="distance-objectives"></a>
Objectives</h1>
<hr/>
<p>In this tutorial we will:</p><ul>
<li><a href="#distance-intro">Introduce the Boost.SIMD vectorized versions of standard library functions</a></li>
<li><a href="#distance-simd">Demonstrate how to achieve significant speed up of expensive calculations using Boost.SIMD</a></li>
<li><a href="#distance-interleave">Show you how to use data which is not in the required order</a></li>
<li><a href="#distance-speed-up">Show how to measure the speed up achieved using Boost.SIMD</a></li>
<li><a href="#distance-performance-analysis">Introduce detailed performance analysis</a></li>
</ul>
<h1><a class="anchor" id="distance-intro"></a>
Distance between two points</h1>
<p>The distance between two points \((x_1,y_1)\), \((x_2,y_2)\) in the Cartesian plane is calculated as follows:</p>
<center> \(\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\).</center><p>We can see that we must use the standard library functions <code>std::sqrt</code> and <code>std::pow</code> in this calculation. So, in order to vectorize this code, we require vectorized versions of these functions. We wish to vectorize the following scalar code</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_points; ++i){</div>
<div class="line">    distance0[i] = <a class="code" href="group__group-arithmetic_ga5317bede3e8e600a8d251111840ff8e2.html#ga5317bede3e8e600a8d251111840ff8e2">std::sqrt</a>(<a class="code" href="group__group-exponential_ga47b252b1553cf117d9f1e1688cbbdfb1.html#ga47b252b1553cf117d9f1e1688cbbdfb1">std::pow</a>(refX - X[i], 2) + <a class="code" href="group__group-exponential_ga47b252b1553cf117d9f1e1688cbbdfb1.html#ga47b252b1553cf117d9f1e1688cbbdfb1">std::pow</a>(refY - Y[i], 2));</div>
<div class="line">  }</div>
</div><!-- fragment --> <h2><a class="anchor" id="distance-simd"></a>
The SIMD Calculation</h2>
<p>We first declare our input data. The X and Y coordinates are stored in two separate vectors. These vectors are assumed to be filled with the correct input data.</p>
<div class="fragment"><div class="line">  std::size_t num_points = 1024000;</div>
<div class="line">  std::size_t alignment = pack_t::alignment;</div>
<div class="line">  <span class="keyword">namespace </span>ba = boost::alignment;</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; X(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; Y(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; distance0(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; distance1(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; distance2(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; distance3(num_points);</div>
<div class="line"></div>
<div class="line">  std::iota(X.begin(), X.end(), float(0));</div>
<div class="line">  std::iota(Y.begin(), Y.end(), float(num_points));</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">float</span> refX, refY;</div>
</div><!-- fragment --> <table  align="center" width="90%" class="table-striped ">
<tr>
<th><dl class="section note">
<dt>Note</dt>
<dd>We use aligned memory to ensure correct behaviour and highest performance</dd>
</dl>
</th></tr>
</table>
<p><b>Boost.SIMD</b> comes with many useful functions for performing vectorized computations. In this example we use the <code>+</code>, <code>-</code>, <code>sqr</code> and <code>sqrt</code> functions. The <code>sqr</code> functions calculates the square of each element of a <b>SIMD</b> vector. The first step is to fill a <code>pack_t</code> with the X and Y coordinates of the reference point. We then apply the formula shown above for calculating the distance between two points.</p>
<div class="fragment"><div class="line">  pack_t vrefX = pack_t(refX);</div>
<div class="line">  pack_t vrefY = pack_t(refY);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_points; i += pack_t::static_size){</div>
<div class="line">    pack_t vX = bs::aligned_load&lt;pack_t&gt;(&amp;X[i]);</div>
<div class="line">    pack_t vY = bs::aligned_load&lt;pack_t&gt;(&amp;Y[i]);</div>
<div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_ga5317bede3e8e600a8d251111840ff8e2.html#ga5317bede3e8e600a8d251111840ff8e2">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefX - vX) + <a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefY - vY));</div>
<div class="line"><span class="comment">//    pack_t res = bs::fast_(bs::sqrt)(bs::sqr(vrefX - vX) + bs::sqr(vrefY - vY));</span></div>
<div class="line">    <a class="code" href="namespaceboost_1_1simd_a4ef87e54c642027f74fbf73e6d75191b.html#a4ef87e54c642027f74fbf73e6d75191b">bs::aligned_store</a>(res, &amp;distance1[i]);</div>
<div class="line">  }</div>
</div><!-- fragment --><h2><a class="anchor" id="distance-interleave"></a>
How to deal with input data which is not properly ordered</h2>
<p>In the above example, we examined the case where the input data was stored in two separate buffers, one each for the  X and  Y coordinates.</p>
<p>However, coordinates are often stored interleaved in memory as follows: \(x_0, y_0, x_1, y_1... , x_n, y_{n-1}\)</p>
<p>We could sort the input data before calculating the distance, however the cost of doing this would negate any gain from using <b>SIMD</b> instructions. To solve this problem, we use the functions <a class="el" href="group__group-swar_gab669729a1c14005370f62f92cd9582d0.html#gab669729a1c14005370f62f92cd9582d0" title="Function object implementing deinterleave_first capabilities. ">boost::simd::deinterleave_first</a> and <a class="el" href="group__group-swar_gaee66a0371a24c012bd69b566813da671.html#gaee66a0371a24c012bd69b566813da671" title="Function object implementing deinterleave_second capabilities. ">boost::simd::deinterleave_second</a> to sort the data in the requied order in <b>SIMD</b> register.</p>
<p>After loading the data into packs v0 and v1, they contain the following elements:</p>
<p>\(v_0 = x_0, y_0, x_1, y_1... , x_{\frac{c}{2}-1}, y_{\frac{c}{2}-1}\)</p>
<p>\(v_1 = x_{\frac{c}{2}}, y_{\frac{c}{2}}, x_{\frac{c}{2}+1}, y_{\frac{c}{2}+1}, ... x_{c-1}, y_{c-1}\)</p>
<p>where c = pack_t::static_size or the number of elements in the pack.</p>
<p>In order to efficiently calculate the distance between our reference point and all of the other points, the data must be re-ordered as follows:</p>
<p>\(v_X = x_0, x_1, ... , x_{c-1} \)</p>
<p>\(v_Y = y_0, y_1, ... , y_{c-1} \)</p>
<p>This is done as follows:</p>
<div class="fragment"><div class="line">  <span class="comment">// The input vector contains interleaved X and Y data, i.e. x0, y0, x1, y1, ..., xn, yn</span></div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; interleaved_data(num_points * 2);</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_points*2;i += 2){</div>
<div class="line">    interleaved_data[i] = i / 2;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; num_points*2;i += 2){</div>
<div class="line">    interleaved_data[i] = (i) / 2 + num_points;</div>
<div class="line">  }</div>
<div class="line">  t0 = high_resolution_clock::now();</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_points * 2; i += pack_t::static_size * 2){</div>
<div class="line">    pack_t v0 = bs::aligned_load&lt;pack_t&gt;(&amp;interleaved_data[i]);</div>
<div class="line">    pack_t v1 = bs::aligned_load&lt;pack_t&gt;(&amp;interleaved_data[i + pack_t::static_size]);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> b0 = <a class="code" href="group__group-bitwise_ga584c320e4df69d36e69cc27ebff8772f.html#ga584c320e4df69d36e69cc27ebff8772f">bs::bitwise_cast</a>&lt;bd::as_floating_t&lt;pack_t&gt;&gt;(v0);</div>
<div class="line">    <span class="keyword">auto</span> b1 = <a class="code" href="group__group-bitwise_ga584c320e4df69d36e69cc27ebff8772f.html#ga584c320e4df69d36e69cc27ebff8772f">bs::bitwise_cast</a>&lt;bd::as_floating_t&lt;pack_t&gt;&gt;(v1);</div>
<div class="line">    <span class="keyword">auto</span> b2 = _mm256_permute2f128_ps(b0,b1,0x20);</div>
<div class="line">    <span class="keyword">auto</span> b3 = _mm256_permute2f128_ps(b0,b1,0x31);</div>
<div class="line"></div>
<div class="line">    pack_t vX =  _mm256_unpacklo_ps( _mm256_unpacklo_ps(b2,b3) , _mm256_unpackhi_ps(b2,b3));</div>
<div class="line">    pack_t vY =  _mm256_unpackhi_ps( _mm256_unpacklo_ps(b2,b3) , _mm256_unpackhi_ps(b2,b3));</div>
<div class="line">    <span class="comment">//pack_t vX = bs::deinterleave_first(v0, v1);</span></div>
<div class="line">    <span class="comment">//pack_t vY = bs::deinterleave_second(v0, v1);</span></div>
<div class="line">   <span class="comment">// std::cout&lt;&lt;&quot; v0 &quot; &lt;&lt; vX0 &lt;&lt; &quot; vx &quot; &lt;&lt; vX &lt;&lt; std::endl;</span></div>
<div class="line">   <span class="comment">// std::cout&lt;&lt;&quot; v1 &quot; &lt;&lt; vY0 &lt;&lt; &quot; vx &quot; &lt;&lt; vY &lt;&lt; std::endl;</span></div>
<div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_ga5317bede3e8e600a8d251111840ff8e2.html#ga5317bede3e8e600a8d251111840ff8e2">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefX - vX) + <a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefY - vY));</div>
<div class="line">    <a class="code" href="namespaceboost_1_1simd_a4ef87e54c642027f74fbf73e6d75191b.html#a4ef87e54c642027f74fbf73e6d75191b">bs::aligned_store</a>(res, &amp;distance2[i/2]);</div>
<div class="line">  }</div>
</div><!-- fragment --> <h1><a class="anchor" id="distance-speed-up"></a>
Measuring the speed up</h1>
<p>If you decide to develop software using <b>Boost.SIMD</b>, performance is clearly very important to you. Therefore, it is necessary to be able to accurately measure the speed-up achieved. In thsi example, we measure the time taken for the main calculation loop using the timing utilities provided by <code>std::chrono</code>. Where available, these functions use hardware timers.</p>
<div class="fragment"><div class="line">  t0 = high_resolution_clock::now();</div>
<div class="line">  pack_t vrefX = pack_t(refX);</div>
<div class="line">  pack_t vrefY = pack_t(refY);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_points; i += pack_t::static_size){</div>
<div class="line">    pack_t vX = bs::aligned_load&lt;pack_t&gt;(&amp;X[i]);</div>
<div class="line">    pack_t vY = bs::aligned_load&lt;pack_t&gt;(&amp;Y[i]);</div>
<div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_ga5317bede3e8e600a8d251111840ff8e2.html#ga5317bede3e8e600a8d251111840ff8e2">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefX - vX) + <a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefY - vY));</div>
<div class="line"><span class="comment">//    pack_t res = bs::fast_(bs::sqrt)(bs::sqr(vrefX - vX) + bs::sqr(vrefY - vY));</span></div>
<div class="line">    <a class="code" href="namespaceboost_1_1simd_a4ef87e54c642027f74fbf73e6d75191b.html#a4ef87e54c642027f74fbf73e6d75191b">bs::aligned_store</a>(res, &amp;distance1[i]);</div>
<div class="line">  }</div>
<div class="line">  t1 = high_resolution_clock::now();</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot; time SIMD &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).count() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> The speed-up can be then calculated by dividing the time taken for the scalar loop by the time taken by the <b>SIMD</b> loop. There are several factors to consider when measuring the performance of code. Firstly, you should ensure that the size of the input data is sufficient to fill the CPU cache. Otherwise, the cache will be "hot" one entering the second loop. This means that all of the data required to complete the calculation will already be loaded into the cache, significantly accelerating the execution of the loop. You shoudl also run the code several times and take the average of the execution times, as this may vary significantly between runs for many reasons. In general, we are interested in the typical runtime of a section of code.</p>
<h1><a class="anchor" id="distance-performance-analysis"></a>
Performance analysis</h1>
<p>This code was run on an x86 machine with an Intel Xeon CPU E3-1240 v3 @ 3.40GHz. It was compiled using g++-4.9 with all optimizations enabled and with the flag -msse4.2. A sample size of 1024000 was used.</p>
<table  align="center" width="25%" class="table-striped table-bordered">
<tr>
<th>Loop </th><th>Time ( \(\mu s\)) </th></tr>
<tr>
<td>Scalar </td><td>3894 </td></tr>
<tr>
<td>SIMD </td><td>846 </td></tr>
<tr>
<td>SIMD Interleaved </td><td>859 </td></tr>
</table>
<p>An SSE vector contains four floats. Therefore, we should expect the speed-up to a maximum of four. However, it is quicker then that. A possible explanation for this is given in the next paragraph. The code was then re-compiled for AVX2 using -mavx2 flag with the following results:</p>
<table  align="center" width="25%" class="table-striped table-bordered">
<tr>
<th>Loop </th><th>Time ( \(\mu s\)) </th></tr>
<tr>
<td>Scalar </td><td>3868 </td></tr>
<tr>
<td>SIMD </td><td>856 </td></tr>
<tr>
<td>SIMD Interleaved </td><td>1407 </td></tr>
</table>
<p>Firstly, we note that as expected the scalar loop took approximately the same time as for sse4.2. However, we would expect that both <b>SIMD</b> loops would execute in half of the time as on SSE4.2 as the register size is twice as large in AVX equipped machines. In this case, the time taken is constant. There are several explanations for this. Firstly, the SSE4.2 code was executed on an AVX equipped processor. Modern processors are very sophisticated, and often they can "upgrade" SSE instruction to its equivalent AVX instruction, if available. Therefore, the code may run twice as fast as predicted. The conclusion of this is that it is not possible to accurately measure the performance of SSE code on an AVX machine. So this begs the questions, why was the SSE code not 8 times faster than the scalar code. Take for example the SSE add intrinsic, which adds two SSE vectors, thus 4 floats in one instruction. Every processor instruction has a latency and a throughput, which for Intel processor are given in the Intel Intrinsics Guide. The latency and throughput for add for example is not necessarily equal to that for the scalar add instruction. Therefore, the use of the <b>SIMD</b> intrinsics does not necessarily result in a 4 times speed-up.</p>
<p>We also can see that the <b>SIMD</b> interleave loop took signicantly longer on AVX then on SSE. The reason for this lies in the functions supported by AVX processors. Not all SSE functions are supported by AVX processors, in this case, there is no corresponding deinterleave first and second intrinsic on AVX/. Therefore, <b>Boost.SIMD</b> splits the avx vector into two SSE vectors before performing the deinterleave operation. It is for this reason that the code takes longer to execute on AVX than on SSE.</p>
<h1><a class="anchor" id="distance-full-code"></a>
Full code</h1>
<p>Here is the full code, should you wish to compile it:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/align/aligned_allocator.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/align/aligned_delete.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/pack.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/fast.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/load.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/aligned_load.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/store.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/aligned_store.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/sqrt.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/sqr.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/plus.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/minus.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/deinterleave_first.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/deinterleave_second.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/simd/function/shuffle.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv){</div>
<div class="line">  <span class="keyword">using namespace </span>std::chrono;</div>
<div class="line">  <span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1simd.html">bs</a> = <a class="code" href="namespaceboost_1_1simd.html">boost::simd</a>;</div>
<div class="line">  <span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1dispatch.html">bd</a> = <a class="code" href="namespaceboost_1_1dispatch.html">boost::dispatch</a>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">using</span> pack_t = <a class="code" href="singletonboost_1_1simd_1_1pack.html">bs::pack&lt;float&gt;</a>;</div>
<div class="line"></div>
<div class="line">  std::size_t num_points = 1024000;</div>
<div class="line">  std::size_t alignment = pack_t::alignment;</div>
<div class="line">  <span class="keyword">namespace </span>ba = boost::alignment;</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; X(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; Y(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; distance0(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; distance1(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; distance2(num_points);</div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; distance3(num_points);</div>
<div class="line"></div>
<div class="line">  std::iota(X.begin(), X.end(), float(0));</div>
<div class="line">  std::iota(Y.begin(), Y.end(), float(num_points));</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">float</span> refX, refY;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">auto</span> t0 = high_resolution_clock::now();</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_points; ++i){</div>
<div class="line">    distance0[i] = <a class="code" href="group__group-arithmetic_ga5317bede3e8e600a8d251111840ff8e2.html#ga5317bede3e8e600a8d251111840ff8e2">std::sqrt</a>(<a class="code" href="group__group-exponential_ga47b252b1553cf117d9f1e1688cbbdfb1.html#ga47b252b1553cf117d9f1e1688cbbdfb1">std::pow</a>(refX - X[i], 2) + <a class="code" href="group__group-exponential_ga47b252b1553cf117d9f1e1688cbbdfb1.html#ga47b252b1553cf117d9f1e1688cbbdfb1">std::pow</a>(refY - Y[i], 2));</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">auto</span> t1 = high_resolution_clock::now();</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot; time scalar &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).count() &lt;&lt; std::endl;</div>
<div class="line">  <span class="comment">// X and Y are assumed to be filled with the required data</span></div>
<div class="line"></div>
<div class="line">  t0 = high_resolution_clock::now();</div>
<div class="line">  pack_t vrefX = pack_t(refX);</div>
<div class="line">  pack_t vrefY = pack_t(refY);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_points; i += pack_t::static_size){</div>
<div class="line">    pack_t vX = bs::aligned_load&lt;pack_t&gt;(&amp;X[i]);</div>
<div class="line">    pack_t vY = bs::aligned_load&lt;pack_t&gt;(&amp;Y[i]);</div>
<div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_ga5317bede3e8e600a8d251111840ff8e2.html#ga5317bede3e8e600a8d251111840ff8e2">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefX - vX) + <a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefY - vY));</div>
<div class="line"><span class="comment">//    pack_t res = bs::fast_(bs::sqrt)(bs::sqr(vrefX - vX) + bs::sqr(vrefY - vY));</span></div>
<div class="line">    <a class="code" href="namespaceboost_1_1simd_a4ef87e54c642027f74fbf73e6d75191b.html#a4ef87e54c642027f74fbf73e6d75191b">bs::aligned_store</a>(res, &amp;distance1[i]);</div>
<div class="line">  }</div>
<div class="line">  t1 = high_resolution_clock::now();</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot; time SIMD &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).count() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The input vector contains interleaved X and Y data, i.e. x0, y0, x1, y1, ..., xn, yn</span></div>
<div class="line">  std::vector&lt;float, ba::aligned_allocator&lt;float, pack_t::alignment&gt;&gt; interleaved_data(num_points * 2);</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_points*2;i += 2){</div>
<div class="line">    interleaved_data[i] = i / 2;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; num_points*2;i += 2){</div>
<div class="line">    interleaved_data[i] = (i) / 2 + num_points;</div>
<div class="line">  }</div>
<div class="line">  t0 = high_resolution_clock::now();</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_points * 2; i += pack_t::static_size * 2){</div>
<div class="line">    pack_t v0 = bs::aligned_load&lt;pack_t&gt;(&amp;interleaved_data[i]);</div>
<div class="line">    pack_t v1 = bs::aligned_load&lt;pack_t&gt;(&amp;interleaved_data[i + pack_t::static_size]);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> b0 = <a class="code" href="group__group-bitwise_ga584c320e4df69d36e69cc27ebff8772f.html#ga584c320e4df69d36e69cc27ebff8772f">bs::bitwise_cast</a>&lt;bd::as_floating_t&lt;pack_t&gt;&gt;(v0);</div>
<div class="line">    <span class="keyword">auto</span> b1 = <a class="code" href="group__group-bitwise_ga584c320e4df69d36e69cc27ebff8772f.html#ga584c320e4df69d36e69cc27ebff8772f">bs::bitwise_cast</a>&lt;bd::as_floating_t&lt;pack_t&gt;&gt;(v1);</div>
<div class="line">    <span class="keyword">auto</span> b2 = _mm256_permute2f128_ps(b0,b1,0x20);</div>
<div class="line">    <span class="keyword">auto</span> b3 = _mm256_permute2f128_ps(b0,b1,0x31);</div>
<div class="line"></div>
<div class="line">    pack_t vX =  _mm256_unpacklo_ps( _mm256_unpacklo_ps(b2,b3) , _mm256_unpackhi_ps(b2,b3));</div>
<div class="line">    pack_t vY =  _mm256_unpackhi_ps( _mm256_unpacklo_ps(b2,b3) , _mm256_unpackhi_ps(b2,b3));</div>
<div class="line">    <span class="comment">//pack_t vX = bs::deinterleave_first(v0, v1);</span></div>
<div class="line">    <span class="comment">//pack_t vY = bs::deinterleave_second(v0, v1);</span></div>
<div class="line">   <span class="comment">// std::cout&lt;&lt;&quot; v0 &quot; &lt;&lt; vX0 &lt;&lt; &quot; vx &quot; &lt;&lt; vX &lt;&lt; std::endl;</span></div>
<div class="line">   <span class="comment">// std::cout&lt;&lt;&quot; v1 &quot; &lt;&lt; vY0 &lt;&lt; &quot; vx &quot; &lt;&lt; vY &lt;&lt; std::endl;</span></div>
<div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_ga5317bede3e8e600a8d251111840ff8e2.html#ga5317bede3e8e600a8d251111840ff8e2">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefX - vX) + <a class="code" href="group__group-arithmetic_ga952ca1c69d0409c9dcfd80ca2f6b3b32.html#ga952ca1c69d0409c9dcfd80ca2f6b3b32">bs::sqr</a>(vrefY - vY));</div>
<div class="line">    <a class="code" href="namespaceboost_1_1simd_a4ef87e54c642027f74fbf73e6d75191b.html#a4ef87e54c642027f74fbf73e6d75191b">bs::aligned_store</a>(res, &amp;distance2[i/2]);</div>
<div class="line">  }</div>
<div class="line">  t1 = high_resolution_clock::now();</div>
<div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot; time SIMD de-interleave &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).count() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --></div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 9 2016 11:06:49 for Boost.SIMD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
