<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- For Mobile Devices -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<title>Boost.SIMD: SIMD Branching</title>
<!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link rel="icon" href="numscale_icon.png">
<link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="numscale.js"></script>
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
<div class="container">
<div class="navbar-header responsive-logo">
<a class="navbar-brand" style="width: 10%" href="https://github.com/NumScale/boost.simd">Boost.SIMD </a>
<a href="http://numscale.implicitweb.fr/" title="Numscale" style="display: block; width: 25%; text-align: right; float: right"><img src="numscale.png" alt="Numscale" style="width:100%; padding-top: 10px; padding-bottom: 10px; " align="right"></a>
</div>
</div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div class="content" id="content">
<div class="container">
<div class="row">
<div class="col-sm-12 panel " style="padding-bottom: 35px;">
<div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="QuickStart.html"><span>Quick&#160;Start</span></a></li>
      <li><a href="tutorials.html"><span>Tutorials</span></a></li>
      <li><a href="faq.html"><span>FAQ</span></a></li>
      <li><a href="modules.html"><span>Reference&#160;documentation</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SIMD Branching </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#branching-objectives">Objectives</a></li>
<li class="level1"><a href="#branching-intro">Branching</a></li>
<li class="level1"><a href="#branching-transfer">Minimizing the transfer of data between the processor and memory</a></li>
</ul>
</div>
<div class="textblock"><p>In this tutorial we will examine how to handle branches in SIMD programs.</p>
<h1><a class="anchor" id="branching-objectives"></a>
Objectives</h1>
<hr/>
<p>In this tutorial we will:</p><ul>
<li><a href="#branching-intro">Show how to efficiently handle branches in SIMD programs</a></li>
<li><a href="#branching-transfer">Demonstrate a useful technique for reducing data transfer</a></li>
<li><a href="#branching-speed">Discuss possible reasons for lower speed-up than expected</a></li>
</ul>
<h1><a class="anchor" id="branching-intro"></a>
Branching</h1>
<p>One of the fundamental principles of <b>SIMD</b> programming is that the same operation must be performed on each element of the <b>SIMD</b> vector. At first glance, this means that vectorized programs do not support conditional statements. Let's take a common image processing operation known as thresholding as an example. Thresholding is an operation to separate a digital image into its background and foreground pixels. Any pixel whose value is less than the choosen threshold is considered to be a background pixel and conversely, any pixel whose value is greater or equal to the threshold is considered to be a foreground pixel. For example:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; image.size(); ++i){</div><div class="line">    <span class="keywordflow">if</span>(image[i] &lt; threshold){</div><div class="line">      binary[i] = 0;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      binary[i] = 1;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">auto</span> t1 = high_resolution_clock::now();</div><div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;scalar &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).count() &lt;&lt; std::endl;</div></div><!-- fragment --><p> Here we have a very clear branch in the code. How can we vectorize this loop?</p>
<div class="fragment"><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1simd.html">bs</a> = <a class="code" href="namespaceboost_1_1simd.html">boost::simd</a>;</div><div class="line">  <span class="keyword">using</span> pack_t = <a class="code" href="classboost_1_1simd_1_1pack.html">bs::pack&lt;std::int16_t&gt;</a>;</div><div class="line">  <span class="keyword">using</span> logical_t = <a class="code" href="classboost_1_1simd_1_1pack.html">bs::pack&lt;bs::logical&lt;std::int16_t&gt;</a>&gt;;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> std::size_t <a class="code" href="group__group-api_gabe9b001105eeb7b19d63240f3b578065.html#gabe9b001105eeb7b19d63240f3b578065">cardinal</a> = pack_t::static_size;</div><div class="line"></div><div class="line">  pack_t v_threshold{threshold};</div><div class="line">  t0 = high_resolution_clock::now();</div><div class="line">  <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; image.size(); i += <a class="code" href="group__group-api_gabe9b001105eeb7b19d63240f3b578065.html#gabe9b001105eeb7b19d63240f3b578065">cardinal</a>){</div><div class="line">    pack_t v_image(&amp;image[i]);</div><div class="line">    logical_t v_res = <a class="code" href="group__group-predicates_ga5b1b1b46c5e05fad1f94379b13a2e888.html#ga5b1b1b46c5e05fad1f94379b13a2e888">bs::is_less</a>(v_image, v_threshold);</div><div class="line">    pack_t v_binary = <a class="code" href="group__group-boolean_ga685ba8459ff04501929692d3202406a5.html#ga685ba8459ff04501929692d3202406a5">bs::if_zero_else_one</a>(v_res);</div><div class="line">    <a class="code" href="namespaceboost_1_1simd_a4ef87e54c642027f74fbf73e6d75191b.html#a4ef87e54c642027f74fbf73e6d75191b">bs::aligned_store</a>(v_binary, &amp;binary[i]);</div><div class="line">  }</div></div><!-- fragment --><p> In this example, we introduce a new type, <code>bs::logical</code>, which is an abstraction for the equivalent of a <code>bool</code> on a particular architecture. Therefore, a pack of <code>bs::logical</code> or a <code>logical_t</code> is the equivalent of a pack of <code>bool</code>. This abstraction is necessary to ensure that any code written using <b>Boost.SIMD</b> is portable due to the differences between how various processors handle operations requiring logical values.</p>
<p>The return type of a comparison operation in C++ is a bool, therefore the return type of the function <code>bs::is_less</code> is a <code>logical_t</code>. This <code>logical_t</code> is then used to generate a <b>SIMD</b> vector of zeros or ones using the function <code>bs::if_zero_else_one</code>. All that's left to do now is to store this vector in its correct location in memory.</p>
<h1><a class="anchor" id="branching-transfer"></a>
Minimizing the transfer of data between the processor and memory</h1>
<p>Many algorithms are memory bound, meaning that the time required to complete the function is mostly determined by the time taken to transfer the data from memory to the processor and back again. Therefore, any operation which reduces the quantity of data to be transferred could significantly accelerate the execution of the code. As you are using <b>Boost.SIMD</b> you are clearly concerned about performance! In this example, the input image is a 16 bit image. However, the output of the thresholding operation is a binary image. Therefore, the output image can safely be stored as an 8 bit image, halfing the quantity of data to be transferred from the processor to memory! <b>Boost.SIMD</b> includes many functions to upgrade and downgrade or <code>split</code> and <code>group</code> data:</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> pack_8 = <a class="code" href="classboost_1_1simd_1_1pack.html">bs::pack&lt;std::int8_t&gt;</a>;</div><div class="line">  std::size_t cardinal_8 = pack_8::static_size;</div><div class="line"></div><div class="line">  t0 = high_resolution_clock::now();</div><div class="line">  std::vector&lt;std::int8_t&gt; binary_8(image_size);</div><div class="line">  <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; image.size(); i += cardinal_8){</div><div class="line">    pack_t v_image0(&amp;image[i]);</div><div class="line">    pack_t v_image1(&amp;image[i + cardinal]);</div><div class="line">    pack_t v_binary0 = <a class="code" href="group__group-boolean_ga685ba8459ff04501929692d3202406a5.html#ga685ba8459ff04501929692d3202406a5">bs::if_zero_else_one</a>(<a class="code" href="group__group-predicates_ga5b1b1b46c5e05fad1f94379b13a2e888.html#ga5b1b1b46c5e05fad1f94379b13a2e888">bs::is_less</a>(v_image0, threshold));</div><div class="line">    pack_t v_binary1 = <a class="code" href="group__group-boolean_ga685ba8459ff04501929692d3202406a5.html#ga685ba8459ff04501929692d3202406a5">bs::if_zero_else_one</a>(<a class="code" href="group__group-predicates_ga5b1b1b46c5e05fad1f94379b13a2e888.html#ga5b1b1b46c5e05fad1f94379b13a2e888">bs::is_less</a>(v_image1, threshold));</div><div class="line">    pack_8 v_binary_group = <a class="code" href="group__group-swar_ga38598b89b469fea0f860e09a73965c47.html#ga38598b89b469fea0f860e09a73965c47">bs::group</a>(v_binary0, v_binary1);</div><div class="line">    <a class="code" href="namespaceboost_1_1simd_a4ef87e54c642027f74fbf73e6d75191b.html#a4ef87e54c642027f74fbf73e6d75191b">bs::aligned_store</a>(v_binary_group, &amp;binary_8[i]);</div><div class="line">  }</div><div class="line">  t1 = high_resolution_clock::now();</div><div class="line">  std::cout&lt;&lt;<span class="stringliteral">&quot;downgrade &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).count() &lt;&lt; std::endl;</div></div><!-- fragment --><p> This extract of code assumes that the input image is a multiple of the output vector size for clarity. This assumption is often false, the previous example, <a class="el" href="tutorial-data.html">Processing data the SIMD way</a> shows how to handle this by adding a scalar loop at the end to process all remaining pixels. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 5 2016 22:03:38 for Boost.SIMD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
